//
//  Dictionary.swift
//  ExSwift
//
//  Created by pNre on 04/06/14.
//  Copyright (c) 2014 pNre. All rights reserved.
//

import Foundation
import Swift

extension Dictionary {
    
    /**
    *  Computes the difference between self and the input dictionaries
    *  @param dictionaries Dictionaries to subtract
    *  @return Difference between self and the input dictionaries
    */
    func difference <V: Equatable> (dictionaries: Dictionary<KeyType, V>...) -> Dictionary<KeyType, V>? {
        
        //  Checks if self's elements are compatbile with V
        if !self.all( { return $1 is V } ) {
            return nil
        }
        
        var result = Dictionary<KeyType, V>()
        
        //  Cast everything to V
        for (key, value) in self {
            result[key] = value as? V
        }
        
        //  Difference
        for dictionary in dictionaries {
            for (key, value) in dictionary {
                if result.has(key) && result[key] == value {
                    result.removeValueForKey(key)
                }
            }
        }
        
        return result
        
    }
    
    /**
     *  Checks if the specified key exists in the dictionary
     *  @param key Key to check
     *  @return true if the key exists
     */
    func has (key: KeyType) -> Bool {

        return indexForKey(key) != nil

    }
    
    /**
     *  Creates a Dictionary with the same keys as self and values generated by running
     *  each (key, value) of self through the mapFunction
     *  @param mapFunction
     *  @return Mapped dictionary
     */
    func mapValues (mapFunction map: (KeyType, ValueType) -> (ValueType)) -> Dictionary<KeyType, ValueType> {

        var mapped = Dictionary<KeyType, ValueType>()

        self.each({
            mapped[$0] = map($0, $1)
        })

        return mapped

    }
    
    /**
     *  Creates a Dictionary with keys and values generated by running
     *  each (key, value) of self through the mapFunction
     *  @param mapFunction
     *  @return Mapped dictionary
     */
    func map (mapFunction map: (KeyType, ValueType) -> (KeyType, ValueType)) -> Dictionary<KeyType, ValueType> {

        var mapped = Dictionary<KeyType, ValueType>()

        self.each({
            let (_key, _value) = map($0, $1)
            mapped[_key] = _value
        })

        return mapped
        
    }
    
    /**
     *  Loops trough each (key, value) pair in self
     *  @param eachFunction
     */
    func each (eachFunction each: (KeyType, ValueType) -> ()) {

        for (key, value) in self {
            each(key, value)
        }

    }
    
    /**
     *  Constructs a dictionary containing every (key, value) pair from self
     *  for which testFunction evaluates to true.
     *  @param testFunction
     *  @return Filtered dictionary
     */
    func filter (testFunction test: (KeyType, ValueType) -> Bool) -> Dictionary<KeyType, ValueType> {
        
        var result = Dictionary<KeyType, ValueType>()
        
        for (key, value) in self {
            if test(key, value) {
                result[key] = value
            }
        }
        
        return result
        
    }
    
    /**
     *  Returns true if self contains no keys
     *  @return True if self is empty
     */
    func isEmpty () -> Bool {
        return Array(self.keys).isEmpty
    }
    
    /**
    *  Returns a new dictionary containing the contents of self and 
    *  the contents of all the dictionaries passed as parameters
    *  @param dictionaries Dictionaries to merge with self
    *  @return Merge result
    */
    func merge (dictionaries: Dictionary<KeyType, ValueType>...) -> Dictionary<KeyType, ValueType> {

        var result = Dictionary<KeyType, ValueType>()
        let allDictionaries = [self] + dictionaries

        for dictionary in allDictionaries {
            for (key, value) in dictionary {
                result[key] = value
            }
        }
        
        return result

    }

    /**
    *  Creates a dictionary composed of keys generated from the results of running each element of self through groupingFunction. The corresponding value of each key is an array of the elements responsible for generating the key.
    *  @param groupingFunction
    *  @return Grouped dictionary
    */
    func groupBy <T> (groupingFunction group: (KeyType, ValueType) -> (T)) -> Dictionary<T, Array<ValueType>> {
        
        var result = Dictionary<T, ValueType[]>();
        
        for (key, value) in self {
            
            let groupKey = group(key, value)
            var array: ValueType[]? = nil
            
            //  This is the first object for groupKey
            if !result.has(groupKey) {
                result[groupKey] = [value]
            } else {
                result[groupKey] = result[groupKey]! + [value]
            }
            
        }
        
        return result
        
    }
    
    /**
    *  Similar to groupBy, but instead of returning a list of values, returns the number of values for each group
    *  @param groupingFunction
    *  @return Grouped dictionary
    */
    func countBy <T> (groupingFunction group: (KeyType, ValueType) -> (T)) -> Dictionary<T, Int> {
        
        var result = Dictionary<T, Int>();
        
        for (key, value) in self {
            
            let groupKey = group(key, value)

            //  This is the first object for groupKey
            if !result.has(groupKey) {
                result[groupKey] = 1
            } else {
                result[groupKey] = result[groupKey]! + 1
            }
            
        }
        
        return result
        
    }
    
    /**
    *  Checks if test returns true for all the elements in self
    *  @param test Function to call for each element
    *  @return True if call returns true for all the elements in self
    */
    func all (test: (KeyType, ValueType) -> (Bool)) -> Bool {
        
        for (key, value) in self {
            if !test(key, value) {
                return false
            }
        }
        
        return true
        
    }
    
    /**
    *  Checks if test returns true for any element of self
    *  @param test Function to call for each element
    *  @return True if call returns true for any element of self
    */
    func any (test: (KeyType, ValueType) -> (Bool)) -> Bool {
        
        for (key, value) in self {
            if test(key, value) {
                return true
            }
        }
        
        return false
        
    }

    /**
    *  Same as Array.reduce
    */
    func reduce <U> (initial: U, combine: (U, Element) -> U) -> U {
        return Swift.reduce(self, initial, combine)
    }

    /**
    *  Removes a (key, value) pair from self and returns it as tuple
    *  @return (key, value)
    */
    mutating func shift () -> (KeyType, ValueType) {
        let key: KeyType! = Array(keys).first()
        let value: ValueType! = removeValueForKey(key)
        
        return (key, value)
    }
    
}

/**
*  Shorthand for the difference
*/

@infix func - <K, V: Equatable> (first: Dictionary<K, V>, second: Dictionary<K, V>) -> Dictionary<K, V> {
    return first.difference(second)!
}

