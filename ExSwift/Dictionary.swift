//
//  Dictionary.swift
//  ExSwift
//
//  Created by pNre on 04/06/14.
//  Copyright (c) 2014 pNre. All rights reserved.
//

import Foundation
import Swift

public extension Dictionary {

    /**
    *  Difference of self and the input dictionaries
    *  @param dictionaries Dictionaries to subtract
    *  @return Difference of self and the input dictionaries
    */
    func difference <V: Equatable> (dictionaries: [Key: V]...) -> [Key: V] {

        //  Cast everything to V
        var result = [Key: V]()

        each {
            if let item = $1 as? V {
                result[$0] = item
            }
        }

        //  Difference
        for dictionary in dictionaries {
            for (key, value) in dictionary {
                if result.has(key) && result[key] == value {
                    result.removeValueForKey(key)
                }
            }
        }

        return result

    }

    /**
    *  Union of self and the input dictionaries
    *  @param dictionaries Dictionaries to join
    *  @return Union of self and the input dictionaries
    */
    func union (dictionaries: Dictionary...) -> Dictionary {

        var result = self

        dictionaries.each { (dictionary) -> Void in
            dictionary.each { (key, value) -> Void in
                result.updateValue(value, forKey: key)
                return
            }
        }

        return result

    }

    /**
    *  Intersection of self and the input dictionaries
    *  @param values Dictionaries to intersect
    *  @return Dictionary of (key, value) couples present in all the dictionaries + self
    */
    func intersection <K, V where K: Equatable, V: Equatable> (dictionaries: [K: V]...) -> [K: V] {

        //  Converts self from <Key, Value> to <K, V>
        let filtered = self.filter({
            (item: Key, value: Value) -> Bool in
            return (item is K) && (value is V)
        }).map({
            (item: Key, value: Value) -> (K, V) in
            return (item as K, value as V)
        })

        //  Intersection self & dictionaries...
        return filtered.filter({
            (item: K, value: V) -> Bool in
            dictionaries.all { $0.has(item) && $0[item] == value }
        })

    }

    /**
    *  Checks if the specified key exists in the dictionary
    *  @param key Key to check
    *  @return true if the key exists
    */
    func has (key: Key) -> Bool {
        return indexForKey(key) != nil
    }

    /**
    *  Creates a Dictionary with the same keys as self and values generated by running
    *  each (key, value) of self through the mapFunction
    *  @param mapFunction
    *  @return Mapped dictionary
    */
    func mapValues <V> (mapFunction map: (Key, Value) -> (V)) -> [Key: V] {

        var mapped = [Key: V]()

        self.each({
            mapped[$0] = map($0, $1)
        })

        return mapped

    }

    /**
    *  Creates a Dictionary with keys and values generated by running
    *  each (key, value) of self through the mapFunction
    *  @param mapFunction
    *  @return Mapped dictionary
    */
    func map <K, V> (mapFunction map: (Key, Value) -> (K, V)) -> [K: V] {

        var mapped = [K: V]()

        self.each({
            let (_key, _value) = map($0, $1)
            mapped[_key] = _value
        })

        return mapped

    }

    /**
    *  Loops trough each (key, value) pair in self
    *  @param eachFunction Function to inovke on each loop
    */
    func each (eachFunction each: (Key, Value) -> ()) {

        for (key, value) in self {
            each(key, value)
        }

    }

    /**
    *  Constructs a dictionary containing every (key, value) pair from self
    *  for which testFunction evaluates to true
    *  @param testFunction Function called to test each key, value
    *  @return Filtered dictionary
    */
    func filter (testFunction test: (Key, Value) -> Bool) -> Dictionary {

        var result = Dictionary()

        for (key, value) in self {
            if test(key, value) {
                result[key] = value
            }
        }

        return result

    }

    /**
    *  Returns true if self doesn't contain any key, false otherwise
    *  @return True if self is empty
    */
    func isEmpty () -> Bool {
        return Array(self.keys).isEmpty
    }

    /**
    *  Creates a dictionary composed of keys generated from the results of
    *  running each element of self through groupingFunction. The corresponding
    *  value of each key is an array of the elements responsible for generating the key.
    *  @param groupingFunction
    *  @return Grouped dictionary
    */
    func groupBy <T> (groupingFunction group: (Key, Value) -> T) -> [T: [Value]] {

        var result = [T: [Value]]()

        for (key, value) in self {

            let groupKey = group(key, value)
            
            // If element has already been added to dictionary, append to it. If not, create one.
            if let elem = result[groupKey] {
                result[groupKey]! += /*elem +*/ [value]
            } else {
                result[groupKey] = [value]
            }
        }

        return result
    }

    /**
    *  Similar to groupBy. Doesn't return a list of values, but the number of values for each group
    *  @param groupingFunction Function called to define the grouping key
    *  @return Grouped dictionary
    */
    func countBy <T> (groupingFunction group: (Key, Value) -> (T)) -> Dictionary<T, Int> {

        var result = Dictionary<T, Int>()

        for (key, value) in self {

            let groupKey = group(key, value)

            // If element has already been added to dictionary, append to it. If not, create one.
            if let elem = result[groupKey] {
                result[groupKey] = elem + 1
            } else {
                result[groupKey] = 1
            }
        }

        return result
    }

    /**
    *  Checks if test returns true for all the elements in self
    *  @param test Function to call for each element
    *  @return True if call returns true for all the elements in self
    */
    func all (test: (Key, Value) -> (Bool)) -> Bool {

        for (key, value) in self {
            if !test(key, value) {
                return false
            }
        }

        return true

    }

    /**
    *  Returns true if test returns true for any element of self
    *  @param test Function to call for each element
    *  @return True if call returns true for any element of self
    */
    func any (test: (Key, Value) -> (Bool)) -> Bool {

        for (key, value) in self {
            if test(key, value) {
                return true
            }
        }

        return false

    }

    /**
    *  Same as Array.reduce
    *  @param initial Initial value
    *  @param combine Function that reduces the dictionary
    *  @return Resulting value
    */
    func reduce <U> (initial: U, combine: (U, Element) -> U) -> U {
        return Swift.reduce(self, initial, combine)
    }

    /**
    *  Return a copy of self, filtered to only have values for the whitelisted keys
    *  @param keys Whitelisted keys
    *  @return Filtered dictionary
    */
    func pick (keys: [Key]) -> Dictionary {
        return filter { (key: Key, _) -> Bool in
            return keys.contains(key)
        }
    }

    /**
    *  Return a copy of self, filtered to only have values for the whitelisted keys
    *  @param keys Whitelisted keys
    *  @return Filtered dictionary
    */
    func pick (keys: Key...) -> Dictionary {
        return pick(unsafeBitCast(keys, [Key].self))
    }

    /**
    *  Equivalent to pick
    *  @param keys Keys to get
    *  @return Dictionary with the given keys
    */
    func at (keys: Key...) -> Dictionary {
        return pick(keys)
    }

    /**
    *  Removes a (key, value) pair from self and returns it as tuple
    *  @return (key, value)
    */
    mutating func shift () -> (Key, Value) {
        let key: Key! = Array(keys).first()
        let value: Value! = removeValueForKey(key)

        return (key, value)
    }
}

/**
*  Shorthand for the difference
*/

public func - <K, V: Equatable> (first: Dictionary<K, V>, second: Dictionary<K, V>) -> Dictionary<K, V> {
    return first.difference(second)
}

/**
*  Shorthand for the intersection
*/
public func & <K, V: Equatable> (first: Dictionary<K, V>, second: Dictionary<K, V>) -> Dictionary<K, V> {
    return first.intersection(second)
}

/**
*  Shorthand for the union
*/
public func | <K, V: Equatable> (first: Dictionary<K, V>, second: Dictionary<K, V>) -> Dictionary<K, V> {
    return first.union(second)
}
